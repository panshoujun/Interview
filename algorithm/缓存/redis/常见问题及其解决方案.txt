缓存雪崩我们可以简单的理解为：
由于原有缓存失效,新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间,
在同一时刻出现大面积的缓存过期),所有原本应该访问缓存的请求都去查询数据库了,
而对数据库CPU和内存造成巨大压力,严重的会造成数据库宕机。从而形成一系列连锁反应,
造成整个系统崩溃。
解决办法：
大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会
有大量的线程对数据库一次性进行读写,从而避免失效时大量的并发请求落到底层存
储系统上。还有一个简单方案就时讲缓存失效时间分散开。

缓存预热这个应该是一个比较常见的概念
缓存预热就是系统上线后,将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户
请求的时候,先查询数据库,然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据
解决思路：
1、直接写个缓存刷新页面,上线时手工操作下；
2、数据量不大,可以在项目启动的时候自动进行加载；
3、定时刷新缓存；

单线程的redis为什么这么快
1纯内存操作
2单线程操作，避免了频繁的上下文切换
3采用了非阻塞I/O多路复用机制
